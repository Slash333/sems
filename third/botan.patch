diff -c5 -r botan/src/lib/x509/x509_ext.cpp botan_patched/src/lib/x509/x509_ext.cpp
*** botan/src/lib/x509/x509_ext.cpp	2020-03-24 13:32:12.088718780 +0200
--- botan_patched/src/lib/x509/x509_ext.cpp	2021-09-14 00:35:53.845208022 +0300
***************
*** 87,96 ****
--- 87,100 ----
        }
     else if(oid == Cert_Extension::Authority_Information_Access::static_oid())
        {
        extn.reset(new Cert_Extension::Authority_Information_Access);
        }
+    else if(oid == Cert_Extension::TNAuthList::static_oid())
+       {
+       extn.reset(new Cert_Extension::TNAuthList);
+       }
     else
        {
        // some other unknown extension type
        extn.reset(new Cert_Extension::Unknown_Extension(oid, critical));
        }
***************
*** 1003,1012 ****
--- 1007,1072 ----
        }
  
     info.add("X509v3.CRLIssuingDistributionPoint", ss.str());
     }
  
+ void TNAuthList::TNEntry::encode_into(class DER_Encoder&) const
+    {
+    throw Not_Implemented("TNEntry encoding");
+    }
+ 
+ void TNAuthList::TNEntry::decode_from(class BER_Decoder& ber)
+    {
+       BER_Object obj = ber.get_next_object();
+       if(obj.is_a(TN_ServiceProviderCode, ASN1_Tag(CONSTRUCTED | CONTEXT_SPECIFIC))) {
+           //ServiceProviderCode
+           type = TN_ServiceProviderCode;
+           BER_Decoder v(obj.bits(),obj.length());
+           ASN1_String s;
+           s.decode_from(v);
+           spc = s.value();
+       } else if(obj.is_a(TN_TelephoneNumberRange, ASN1_Tag(CONSTRUCTED | CONTEXT_SPECIFIC))) {
+           //TelephoneNumberRange
+           type = TN_TelephoneNumberRange;
+           ber.start_cons(SEQUENCE);
+           while(ber.more_items()) {
+               range.emplace_back();
+               auto &range_entry = range.back();
+               ASN1_String s;
+               s.decode_from(ber);
+               range_entry.start = s.value();
+               ber.decode(range_entry.count);
+           }
+           ber.end_cons();
+       } else if(obj.is_a(TN_TelephoneNumber, ASN1_Tag(CONSTRUCTED | CONTEXT_SPECIFIC))) {
+           //TelephoneNumber
+           type = TN_TelephoneNumber;
+           BER_Decoder v(obj.bits(),obj.length());
+           ASN1_String s;
+           s.decode_from(v);
+           one = s.value();
+       } else {
+           throw Decoding_Error("unexpected TNEntry type");
+       }
+    }
+ 
+ std::vector<uint8_t> TNAuthList::encode_inner() const
+    {
+    throw Not_Implemented("TNAuthList encoding");
+    }
+ 
+ void TNAuthList::decode_inner(const std::vector<uint8_t>& in)
+ {
+    m_size = in.size();
+    BER_Decoder(in).decode_list(m_tn_entries).verify_end();
+ }
+ 
+ void TNAuthList::contents_to(Data_Store&, Data_Store&) const
+    {
+    // No information store
+    }
+ 
  std::vector<uint8_t> Unknown_Extension::encode_inner() const
     {
     return m_bytes;
     }
  
diff -c5 -r botan/src/lib/x509/x509_ext.h botan_patched/src/lib/x509/x509_ext.h
*** botan/src/lib/x509/x509_ext.h	2020-03-24 13:32:12.088718780 +0200
--- botan_patched/src/lib/x509/x509_ext.h	2021-09-14 00:35:53.845208022 +0300
***************
*** 736,745 ****
--- 736,803 ----
  
        CRL_Distribution_Points::Distribution_Point m_distribution_point;
     };
  
  /**
+  * TNAuthList extension
+  * https://datatracker.ietf.org/doc/html/rfc8226
+ */
+ class BOTAN_PUBLIC_API(2,0) TNAuthList final : public Certificate_Extension
+    {
+    public:
+       class BOTAN_PUBLIC_API(2,0) TNEntry final : public ASN1_Object
+          {
+          public:
+             enum Type {
+               TN_ServiceProviderCode = 0,
+               TN_TelephoneNumberRange,
+               TN_TelephoneNumber
+             };
+             struct TelephoneNumberRange {
+                std::string start;   //TelephoneNumber (IA5String)
+                size_t count;  //2..MAX
+             };
+             void encode_into(class DER_Encoder&) const override;
+             void decode_from(class BER_Decoder&) override;
+ 
+             Type get_type() const { return type; }
+ 
+             const std::string getServiceProviderCode() const
+             { return spc; }
+ 
+             const std::vector<TelephoneNumberRange> getTelephoneNumberRange() const
+             { return range; }
+ 
+             const std::string getTelephoneNumber() const
+             { return one; }
+ 
+          private:
+             Type type;
+             std::string spc;                         //ServiceProviderCode
+             std::vector<TelephoneNumberRange> range; //TelephoneNumberRange
+             std::string one;                         //TelephoneNumber
+          };
+ 
+       TNAuthList* copy() const override { return new TNAuthList(); }
+       static OID static_oid() { return OID("1.3.6.1.5.5.7.1.26"); }
+       OID oid_of() const override { return static_oid(); }
+ 
+       size_t get_size() const { return m_size; }
+       const std::vector<TNEntry> get_entries() const { return m_tn_entries; }
+ 
+    private:
+       std::string oid_name() const override { return "X509v3.TNAuthList"; }
+ 
+       std::vector<uint8_t> encode_inner() const override;
+       void decode_inner(const std::vector<uint8_t>& in) override;
+       void contents_to(Data_Store&, Data_Store&) const override;
+ 
+       size_t m_size;
+       std::vector<TNEntry> m_tn_entries;
+    };
+ 
+ /**
  * An unknown X.509 extension
  * Will add a failure to the path validation result, if critical
  */
  class BOTAN_PUBLIC_API(2,4) Unknown_Extension final : public Certificate_Extension
     {
